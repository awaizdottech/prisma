generator client {
  provider = "prisma-client-js"
}

// this is what generates the client which interacts with the db & gets updated whenever we migrate
// we can use graphql with generator

// only one datasource allowed as prisma works with only one at a time
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  // field type modifier attributes(@)
  id                Int              @id @default(autoincrement()) // these @... are field lvl attributes
  name              String
  age               Int
  email             String           @unique
  role              Role             @default(BASIC)
  // preferences     Json
  // blob Bytes
  // y Unsupported("") this comes handy when we are migrating an existing db which has unsupported data type in it
  // mobileNumber BigInt
  // x Decimal
  writtenPosts      Post[]           @relation("writtenPosts")
  favPosts          Post[]           @relation("favPosts")
  userPreferences   UserPreferences? @relation(fields: [userPreferencesId], references: [id])
  userPreferencesId String?          @unique

  @@unique([age, name]) // this is block lvl attribute, that specifies we cant have two users with both name & age same
  @@index([email]) // indexes are by default created on u  nique feilds
}

model UserPreferences {
  id           String  @id @default(uuid())
  emailUpdates Boolean
  user         User?
  // we can define the one-to-one relation from here as well as below, but this arises problems at deletion of the user. so instead we define the relation in user which deletes user but not prefernces which should be deleted separately
  // from utube comment: Other alternatives to switching around the one-to-one relationship is 
  // a) when deleting, delete the dependent (preference) table first then the main table
  // b) in the dependent table (preference) on the relationship put a cascade delete. In this case only need to delete the user table and it will auto delete related entry in the preference table.
  //1. When you tried to delete the user and userPreferences: It would have been way better to use the resp. delete function for the preferences first. As same as you would do when "cleaning" the DB usually.

  // user         User    @relation(fields: [userId], references: [id])
  // userId       Int     @unique
}

model Post {
  id         String      @id @default(uuid())
  title      String
  avgRating  Float
  createdAt  DateTime    @default(now()) // DateTime is the only time related data type in prisma
  updatedAt  DateTime    @updatedAt
  author     User        @relation("writtenPosts", fields: [authorId], references: [id]) // @relation... got generated by the formatter
  authorId   Int // got generated by the formatter
  favBy      User?       @relation("favPosts", fields: [favById], references: [id])
  favById    Int?
  categories Catergory[]

  // @@id([title,authorId])
}

model Catergory {
  id    String @id @default(uuid())
  posts Post[]
  name  String @unique
}

enum Role {
  BASIC
  ADMIN
  EDITOR
}
